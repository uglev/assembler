						;Всё, что следует за значком ";" - это комментарий.

.286						;Разрешает ассемблирование   непривилегированных   инструкций
       						;процессора 80286  (реальный  режим) и инструкций арифметического
       						;сопроцессора 80287.

CSEG segment    				;Даём имя сегменту, а точнее определяем абсолютный 
						;сегмент в памяти программ по определённому адресу.
						;Имя нашего сегмента будет CSEG.

assume cs:CSEG, ds:CSEG, es:CSEG, ss:CSEG       ;Задаём сегментные регистры, которые будем использовать для
       						;вычисления действующего адреса для всех меток и переменных, опре-
       						;делённых  для  сегмента  или группы сегментов с указанным именем.
						;У нас их четыре, - CS, DS, ES, SS и они будут указывать на наш 
						;единственный сегмент (мы его назвали CSEG). 

org 100h 					;Устанавливаем счётчик инструкций в текущем сегменте в  соот-
       						;ветствии с адресом, задаваемым "выражением".
						;Сейчас этот счётчик равен 100h - используется для всех программ 
						;типа .com

begin:						;Метка начала программы.

mov ah,1Ah                                      ;Установим DTA в массив.
mov dx,offset dta
int 21h

call Find_first					;Ищем первый файл.
jc Message_bad					;Нет txt-файлов - на выход.

goto_cycle:					;Начало цикла.
                                           
mov ax,3D02h					;Загружаем в регистр ah число 3Dh (функция открытия
						;файла с записью), а в al число 02h (пишем в конец).
						;Можно было записать и так - mov ah,3Dh
						;mov al,02h

mov dx,offset dta+1Eh                           ;Указываем адрес файла в DTA (по умолчанию он 1Eh от начала DTA,
int 21h						;Выполняем функцию.

mov Handle,ax					;При открытии файлу будет присвоен номер, его и
						;сохраняем для дальнейших действий,
mov bx,ax					;а заодно и сохраняем его в bx.

mov ah,3Fh 					;Читаем файл
mov cx,1024                                     ;с длиной 1Кб.
mov dx,offset Finish
int 21h						;Выполняем функцию.

push ax                                         ;В стеке - число реально прочитанных байт.

mov si,offset Name_virus                        ;Проверяем, "заражён" ли файл.
mov di,ax                                       ;В DI - длина файла.
add di,offset Finish                            ;В DI - адрес конца файла.
sub di,5					;DI установлен на считанного конец файла - 5 байт (начало метки).
mov cx,5
repe cmpsb
jne close_file

mov si,di		                        ;В ax - адрес конца программы.
sub si,182h					;Вычитаем длину вируса и получаем адрес его начала.
sub si,3					;Минут три байта. Их мы и будем восстанавливать.
mov di,offset Finish		                ;В di - адрес области за всем файлом (начало считанной программы).
mov cx,3                                        ;Перемещаем (сохраняем) 3 байта.
rep movsb

mov dx,0h					;Устанавливаем указатель с начала файла +0h.
mov cx,0h                                       ;+0h мы указали потому, что будем
mov ax,4200h                                    ;перезаписывать считанный файл с первого байта.
int 21h                                         

mov ah,40h                                      ;Записываем программу (в т.ч.$) из смещения Finish 
mov dx,offset Finish	                        ;по адресу, указанному выше.
pop cx                                          ;Возвращаем длину считанной программы в cx.
						;Стек обнулён.
sub cx,182h					;Вычитаем длину первоначальной программы.
sub cx,3					;И три байта.
int 21h

mov ah,40h                                      ;Обрезаем программу до настоящей длины. 
xor cx,cx                                       ;Впрочем, можно было использовать и функцию 3Ch
int 21h                                         ;(создание нового файла).
                                      
mov ah,3Eh                                      ;Используем функцию закрытия файла.
mov bx,Handle                                   ;Для закрытия обязательно "вспоминаем" его номер,
						;номер у нас был сохранён в Handle.
int 21h                                         ;Выполняем функцию.

Message_ok:					;Подпрограмма успешного вывода строки и выхода.
mov dx,offset Mess_ok
call Print

mov dx,offset dta+1Eh
call Print

mov dx,offset Perevod_stroki                    ;Напечатали сообщение, что вирус найден и вылечен.
call Print

Find_next_file:
call Find_next					;Ищем следующий файл.
jnc goto_cycle					;Нашли ещё один файл; прыгаем на метку.

int 20h

close_file: 
mov ah,3Eh                                      ;Используем функцию закрытия файла.
mov bx,Handle                                   ;Для закрытия обязательно "вспоминаем" его номер,
						;номер у нас был сохранён в Handle.
int 21h                                         ;Выполняем функцию.
jmp Find_next_file
 
Message_bad: 					;Подпрограмма вывода сообщения об ошибке и выхода.
mov dx,offset Mess_bad
call Print
int 20h   

Find_first proc                                 ;Подпрограмма поиска первого файла.
mov ah,4Eh					;Ищем первый файл по маске (функция 4Eh).
xor cx,cx					;Атрибуты обычные. Смотрим, что в CX.
mov dx,offset File_mask 			;Адрес маски в DS:DX
int 21h						;В DTA заносится имя найденного файла.
ret
Find_first endp
                                                ;Подпрограмма поиска следующего файла.
Find_next proc
mov dx,offset dta				;DS:DX указывают на DTA.
xor cx,cx	                                ;CX=0.
mov ah,4Fh    		                        ;4Fh - поиск следующего файла.
int 21h                                         ;В DTA заносится имя найденного файла.
ret
Find_next endp

Print proc
mov ah,9
int 21h
ret
Print endp
         
File_mask db '*.com',0				;Маска файла.

dta db 2ch dup (?) 				;Определяем массив для DTA.
db "$"                                          ;$ - для того, чтобы определить окончание имени файла.

Name_virus db '22:55'				;Маска файла для поиска вируса.

Mess_ok db 'Обнаружен вирус 22:55! Следующий файл вылечен: $'      ;Успешное сообщение и сообщение об ошибке (ниже).

Mess_bad db 'Заражённых файлов не найдено!$'

Perevod_stroki db 0dh,0ah,'$'                   ;Символ перевода строки.

Handle dw 0FFFFh                                ;Определяем переменную (для идентификатора файла).

Finish equ $					;Метка конца нашей программы!

CSEG ends
end begin